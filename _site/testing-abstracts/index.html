<!doctype html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Unit testing abstract classes in React</title>
    <meta name="description" content="">
    <link rel="alternate" href="." type="application/atom+xml" title="">
    <link rel="alternate" href="." type="application/json" title="">
  </head>
  <body>
    <header>
      <h1><a href="/"></a></h1>
    </header>

    <main>
      <h1>Unit testing abstract classes in React</h1>

<p>In unit testing with Jest and Enzyme, a shallow render is a good way to test whether a component works like it should. But with abstract classes[^1] that don’t have a <code>render()</code> method (like one I’m trying to test right now), this fails. So how can we test abstracts?</p>
<h2>A simple abstract class</h2>
<p>Our abstract may look something like this calculator. For the sake of simplicity, it can only do one operation (but that, it can do very well!)</p>
<pre><code class="language-jsx">abstract class AbstractCalculator extends React.Component {
  constructor(props) {
    super(props);
    this.state = {result: 0};
    this.addOne = this.addOne.bind(this);
  }

  addOne() {
    const result = this.state.result + num;
    this.setState({result});
  }
}
</code></pre>
<p>This class could be used as follows:</p>
<pre><code class="language-jsx">class Calculator extends AbstractCalculator {
  constructor(props) {
    super(props);
  }

  render() {
    return (
      &lt;div&gt;
        &lt;strong&gt;{this.state.result}&lt;/strong&gt;
        &lt;button onClick={this.props.addOne}&gt; +1 &lt;/button&gt;
      &lt;/div&gt;
    );
  }
}
</code></pre>
<h2>The fun part: testing!</h2>
<p>Normally, a test for a React class using Jest and Enzyme would look something like this:</p>
<pre><code class="language-jsx">describe('Calculator', () =&gt; {
  const props = {/* add some props here */};
  const calc = shallow(&lt;Calculator {...props} /&gt;);

  it('works', () =&gt; {
    expect(calc).toBeTruthy();
  });
});
</code></pre>
<p><strong>This will not work for abstracts.</strong></p>
<p>If we try to use any of Enzyme’s renderers, e.g. <code>shallow(&lt;AbstractComponent {...props} /&gt;)</code>, we will get an error like this: <code>TypeError: this._instance.render is not a function</code>. Indeed, it is not. But we should still be able to test the rest of <code>AbstractComponent</code>’s methods.</p>
<p>We could test the class <code>Calculator</code> that implements <code>AbstractCalculator</code>, but that would not allow for isolated testing of our abstract.</p>
<p>So let’s approach this as testing a class, rather than a React component. Instead of shallow rendering, we just create a new instance and test its methods on this instance.[^2] As for the props, they are, in essence, the parameters of the constructor function for the class, so we will just pass them as params when creating the test instance.</p>
<pre><code class="language-jsx">import AbstractCalculator from 'path/to/AbstractCalculator';

describe('AbstractCalculator', () =&gt; {
  const props = {/* some test props */};
  const calculator = new AbstractCalculator(props);

  it('works', () =&gt; {
    expect(calculator).toBeTruthy();  
  });
});
</code></pre>
<p>Voilà! It works.</p>
<p>As for state changes, we will have to mock the abstract’s <code>setState</code> method, otherwise we get <code>Warning: Can’t call setState on a component that is not yet mounted.</code></p>
<pre><code class="language-jsx">it('adds correctly', () =&gt; {
  calculator.setState = jest.fn();
  calculator.state.result = 7;

  calculator.addOne();

  expect(calculator.setState).toBeCalledWith({result: 8});  
});
</code></pre>
<p>Thatʼs all — to be honest, the solution was simpler and more straightforward than I had imagined. In essence, an abstract class is just a class that can be reused easily, so it behaves just like a class in TypeScript. In our oversimplified example, that is. :)</p>
<hr>
<h4>References</h4>
<p>[^1]: See the <a href="https://www.typescriptlang.org/docs/handbook/classes.html">TypeScript Handbook</a> for more explanation of abstract classes (youʼll have to scroll down a little.)</p>
<p>[^2]: Note that creating an instance with <code>new</code> from an abstract class should not be done anywhere else, as abstract classes are there for other classes to implement.</p>


<hr>
<ul><li>Next: <a href="/serverless/">Building an API proxy with Serverless — Part 1</a></li><li>Previous: <a href="/console/">console.log(&#39;colours!&#39;)</a></li>
</ul>

    </main>

    <footer></footer>

    <!-- Current page: /testing-abstracts/ -->
  </body>
</html>
