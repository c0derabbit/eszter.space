<!doctype html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Acceptance testing with Cucumber and Capybara</title>
    <meta name="description" content="">
    <link rel="alternate" href="." type="application/atom+xml" title="">
    <link rel="alternate" href="." type="application/json" title="">
  </head>
  <body>
    <header>
      <h1><a href="/"></a></h1>
    </header>

    <main>
      <h1>Acceptance testing with Cucumber and Capybara</h1>

<p>One of my first tasks as a developer was to migrate endless tests from Twist to <a href="https://docs.cucumber.io">Cucumber</a>. Since then, I have written and refactored countless more, but I never had to set up Cucumber testing from zero. Until now.<!-- more --> It was really not complicated, but it took me a while to get everything going. This is what I’ve come up with.</p>
<h2>Prerequisites</h2>
<p><a href="http://bundler.io/">Bundler</a> — the Ruby equivalent of npm. Just <code>gem install bundler</code>.
phantomjs — get it from <a href="https://brew.sh">homebrew</a>: <code>brew install phantomjs</code></p>
<h2>What to test?</h2>
<p>I’m prioritising main user stories — Can they log in and out? Can they navigate the page? Do they see the right content? Are more items loaded after they scroll a table? Can they submit forms and create items (e.g. messages, events)? Do the actions they perform have the right effect? Can they view and download invoices? …and so forth. I have an excel sheet for them — this way, even non-coders can add (request) test cases; and it’s a good way to track progress.
One thing is for sure though: whenever something breaks, if it wasn’t tested before, I write a test for it.</p>
<h2>Setup</h2>
<p>I will demo what I did for testing a simple sign in on our client-facing dashboard. I chose Selenium webdriver, because that’s what I’m used to, but <a href="https://github.com/teampoltergeist/poltergeist">Poltergeist</a> looks very promising as well. I might try it out and compare experiences.</p>
<p>Our directory structure will look something like this:</p>
<pre><code>.gitignore
.secrets
Gemfile
Rakefile
features/
	|-- sign.feature
	|-- step_definitions/
		|-- sign.rb
	|-- support/
		|-- env.rb
</code></pre>
<p>First of all, let’s be secure and not push secrets to GitHub, even if it’s a private repo. Let’s keep them local or on the CI. For this, we have a <code>.secrets</code> file that will hold our secrets. (Replace with your own – btw these creds are fake.)</p>
<pre><code class="language-sh">export TEST_USER=kitten@cats-net.com
export TEST_PW=CorrectHorseBatteryStaple
</code></pre>
<p>Let’s put this file in our <code>.gitignore</code>, to avoid pushing it accidentally.</p>
<pre><code class="language-sh"># .gitignore

.secrets
</code></pre>
<p>For JS developers, our <code>Gemfile</code> is basically what <code>package.json</code>’s <code>dependencies</code> or <code>requirements.txt</code> does. Once we have it, we can run <code>bundle install</code> and it installs all dependencies.</p>
<pre><code class="language-rb"># Gemfile

source &quot;https://rubygems.org&quot;
gem 'rake'
group(:test) do
	gem 'cucumber'
  gem 'capybara'
  gem 'rspec'
  gem 'poltergeist'
  gem 'selenium-webdriver'
  gem 'chromedriver-helper'
end
</code></pre>
<p>I think about the <code>Rakefile</code> as the <code>scripts</code> part of a <code>package.json</code>.<br>
It enables us to call <code>rake features</code> from the command line, which in turn will run all our tests.</p>
<pre><code class="language-rb"># Rakefile

require 'cucumber'
require 'cucumber/rake/task'

task default: :features

Cucumber::Rake::Task.new(:features) do |t|
  t.cucumber_opts = &quot;--format pretty&quot;
end
</code></pre>
<p>Some more configuration in <code>env.rb</code>, and we are good to go. Here, we register a webdriver for the tests to run against, and configure an <code>app_host</code>, which will be our base url.</p>
<pre><code class="language-rb"># features/support/env.rb

require 'capybara'
require 'capybara/cucumber'

Capybara.register_driver :selenium do |app|
  Capybara::Selenium::Driver.new(app, :browser =&gt; :chrome)
end

Capybara.configure do |config|
  config.default_driver = :selenium
  config.app_host = 'https://my-awesome-pets.com'
end

World(Capybara)
</code></pre>
<h2>Ready for our first feature test?</h2>
<p>Features are written in <a href="https://github.com/cucumber/cucumber/wiki/Gherkin">Gherkin</a>, an easy-to-read templating language that goes well with Cucumber.</p>
<pre><code class="language-gherkin"># features/sign.feature

Feature: Sign in

  Scenario: Sign in and see cats
    Given I am on the Sign in page
    When I sign in
    Then I should see cats
</code></pre>
<p>These <code>Given</code>, <code>When</code> and <code>Then</code> steps are regular expressions, and they can be matched to step definitions like this:</p>
<pre><code class="language-rb"># features/step_definitions/sign.rb

Given /^I am on the Sign in page$/ do
  visit('/sign-in') # we already have the base_url from env.rb
  expect(page).to have_content('Sign in') # let's check if this really works
end

And /^I sign in$/ do
  fill_in 'email', :with =&gt; $test_user
  fill_in 'password', :with =&gt; $test_pw
  find('button[type=&quot;submit&quot;]').click
end

Then /^I should see (cats|dogs)$/ do |things|
  expect(page).to have_content(things) # in our case, it will look for 'cats'.
end
</code></pre>
<p>Read more about expects and other matchers <a href="https://relishapp.com/rspec/rspec-expectations/docs/built-in-matchers">here</a>.</p>
<p>That’s it, running <code>rake features</code> should fire up a Chrome browser, visit <code>my-awesome-pets.com</code>, sign in successfully, and report the results in the command line.</p>


<hr>
<ul><li>Next: <a href="/sidebar/">Flexbox with fixed sidebar</a></li><li>Previous: <a href="/protonmail/">Creating a custom ProtonMail theme</a></li>
</ul>

    </main>

    <footer></footer>

    <!-- Current page: /acceptance-testing/ -->
  </body>
</html>
