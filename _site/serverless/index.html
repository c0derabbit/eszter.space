<!doctype html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Building an API proxy with Serverless — Part 1</title>
    <meta name="description" content="">
    <link rel="alternate" href="." type="application/atom+xml" title="">
    <link rel="alternate" href="." type="application/json" title="">
  </head>
  <body>
    <header>
      <h1><a href="/"></a></h1>
    </header>

    <main>
      <h1>Building an API proxy with Serverless — Part 1</h1>

<p>I’m back to building a weather app, this time not in Flask, but React. I wanted to skip the server part, but DarkSky is strict about CORS[^1], so I had to build a proxy. Not really a front-end topic, but good to know if you work daily with backend engineers (which I do).</p>
<h2>Enter serverless</h2>
<p>Constantly running a server just to proxy a single API call would be an overkill — <a href="https://serverless.com/">Serverless</a> on <a href="https://aws.amazon.com/lambda/">AWS Lambda</a> is just the perfect way to solve this[^2]. Of course, serverless is only as serverless as the cloud is not physical. It still runs on a server, but it’s someone else’s (in this case, AWS).</p>
<p>First, we’ll have to install serverless:</p>
<pre><code class="language-sh">yarn global add serverless
</code></pre>
<p>Then create our service:</p>
<pre><code class="language-sh">sls create --template aws-nodejs --path weather-service
cd weather-service
</code></pre>
<p>By the way, <code>sls</code> is a shorthand for <code>serverless</code>. Wherever you see <code>serverless</code> in the docs, you can use <code>sls</code> instead.
The <a href="https://serverless.com/framework/docs/providers/aws/guide/quick-start/">quick start guide</a> suggests to deploy now, but we can skip this until we are ready, and test our proxy locally. Let’s see what we have so far:</p>
<pre><code class="language-sh">sls invoke local -f hello
</code></pre>
<p>If we’ve done everything right (not much to break so far), the output should be:</p>
<pre><code class="language-json">{
  &quot;statusCode&quot;: 200,
  &quot;body&quot;: &quot;{\&quot;message\&quot;:\&quot;Go Serverless v1.0! Your function executed successfully!\&quot;,\&quot;input\&quot;:\&quot;\&quot;}&quot;
}
</code></pre>
<p>Later, we can test the deployed function by calling <code>sls invoke -f hello</code> (without <code>local</code>), but that will count against our AWS Lambda usage.</p>
<h2>Let’s turn this into a DarkSky API gateway</h2>
<p>First, I’d like to call my function something more meaningful, maybe <code>getWeather</code>. For this, let’s change the function name in <code>serverless.yml</code>:</p>
<pre><code class="language-yaml">functions:
  getWeather:
    handler: handler.getWeather
</code></pre>
<p>And in <code>handler.js</code>, <code>module.exports.hello</code> should become:</p>
<pre><code class="language-js">module.exports.getWeather = () =&gt; { … }
</code></pre>
<p>Now if we try <code>sls local invoke -f hello</code>, it will fail, because there is no <code>hello</code> function. However, <code>sls local invoke -f getWeather</code> will work like charm!</p>
<h2>Ok, on to the weather!</h2>
<p>I will use the <a href="https://github.com/request/request#readme">request</a> library for handling requests, for no particular reason, other than it’s simple and works well with serverless. There’s no magic here, just calling <a href="https://darksky.net/dev/docs">Dark Sky API</a> with my secret key and some hard-coded coordinates (for now). Getting the API key from <code>process.env</code> is also a temporary solution optimised for local invokes, this may change in part 2.</p>
<pre><code class="language-js">'use strict';
const request = require('request');

module.exports.getWeather = (event, context, callback) =&gt; {
  const headers = {'Access-Control-Allow-Origin': '*'};

  request.get(
    { url: `https://api.darksky.net/forecast/${process.env.DARKSKY_KEY}/44,32` },
    (err, res, body) =&gt; {
      if (err) {
        const response = { statusCode: 404, headers, body: err };
        callback(null, response);
      } else {
        const response = { statusCode: res.statusCode, headers, body };
        callback(null, response);
      }
    }
  );
};
</code></pre>
<p>Now, <code>sls invoke</code> will return the current weather for those coordinates. You can check out the <a href="https://github.com/c0derabbit/weather/tree/master/server">full source on github</a>.</p>
<p>In my next post, I will show how to deploy the function to AWS Lambda, how to handle requests, and how to create API endpoints.
Until then, and <a href="https://adventofcode.com/">happy holidays</a>!</p>
<hr>
<h4>References</h4>
<p>[^1]: <a href="https://darksky.net/dev/docs/faq#cross-origin">Dark Sky API:  Frequently Asked Questions</a>: “If you were to make API calls from client-facing code, anyone could extract and use your API key, which would result in a bill that you’d have to pay. We disable CORS to help keep your API secret key a secret.” Fair enough.</p>
<p>[^2]: Plus, AWS Free Tier includes 1 million monthly invokes.</p>


<hr>
<ul><li>Next: <a href="/serverless-pt2/">Building an API proxy with Serverless — Part 2</a></li><li>Previous: <a href="/testing-abstracts/">Unit testing abstract classes in React</a></li>
</ul>

    </main>

    <footer></footer>

    <!-- Current page: /serverless/ -->
  </body>
</html>
