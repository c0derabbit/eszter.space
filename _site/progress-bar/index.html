<!doctype html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Building a reading progress bar</title>
    <meta name="description" content="">
    <link rel="alternate" href="." type="application/atom+xml" title="">
    <link rel="alternate" href="." type="application/json" title="">
  </head>
  <body>
    <header>
      <h1><a href="/"></a></h1>
    </header>

    <main>
      <h1>Building a reading progress bar</h1>

<p>For this post, I will do what I did with <a href="https://eszter.space/blog/typing-animation">Typing animation with JavaScript</a>:
start from zero and experiment my way through the problem, to show it’s not that hard to build impressive animations. A reading progress bar this time.</p>
<p>(It should already be done, look at the colourful bar at the top! But I will explain the whole process below.)</p>
<hr>
<p>What I am trying to achieve is similar to how <a href="https://demo.ghost.io/welcome/">Ghost indicates progress</a> on their default theme.</p>
<p>My initial hunch is that it has to do with scroll position and the blog post’s height. Quite useful in this case if blog posts sit in their own nice semantic <code>&lt;article&gt;</code> elements, so we don’t have to rely on the height of the full <code>body</code> and account for the height of whatever is below the blog post itself. Our progress bar should show the exact reading position of the post itself, excluding related articles and tall footers!</p>
<h2>Letʼs do some maths</h2>
<p>So we want to project our vertical scroll position onto a horizontal bar ranging from 0 to 100%. 100% means we have reached the end of the blog post, and its bottom edge is in view. Letʼs see what we know, and how can we use it. <code>element</code> will be our blog post element.</p>
<ul>
<li><code>window.innerHeight</code>: our window size</li>
<li><code>document.body.clientHeight</code>: the body height</li>
<li><code>window.scrollY</code>: how many pixels we have scrolled</li>
<li><code>element.offsetTop</code>: where our blog post starts[^1]</li>
<li><code>element.clientHeight</code>: the blog post element height</li>
</ul>
<p>The actual scroll trajectory to measure starts from the bottom of the non-scrolled page (because that is the bottom-most thing we can see without scrolling), and ends at the bottom of the element. The distance between these two points, <code>(element.clientHeight + element.offsetTop) - window.innerHeight</code>, is equal to 100% of the scroll distance.</p>
<p>We only need to know how much of this distance we have covered (or, how much we have scrolled so far) to show the actual progress.</p>
<h2>Turning it into code</h2>
<p>One thing I have noticed is that in order to measure progress accurately, we should wait for all the elements to be loaded, so we will do everything on load. Once this is done, we just need a fixed <code>div</code> that sits at the top edge of our window and has a bright background. It should start with 0% width, which we will update as we scroll.</p>
<pre><code class="language-html">&lt;div id=&quot;progress-bar&quot;&gt;&lt;/div&gt;
</code></pre>
<pre><code class="language-css">#progress-bar {
  width: 0%;
  position: fixed;
  top: 0;
  left: 0;
  height: 6px;
  background: linear-gradient(to right, #ecd2fe, #feaaaa);
}
</code></pre>
<pre><code class="language-js">window.onload = () =&gt; {
  const post = document.getElementsByTagName('article')[0];
  const progressBar = document.getElementById('progress-bar');
  const distance = (post.clientHeight + post.offsetTop) - window.innerHeight;

  window.addEventListener('scroll', () =&gt; {
    const progress = window.scrollY / distance * 100;
    progressBar.style.width = `${progress}%`;
  });
}
</code></pre>
<p>This is the actual code I am using for this page. Feel free to replicate and modify! :)</p>
<div id="progress-bar"></div>
<style>
  #progress-bar {
    width: 0%;
    position: fixed;
    top: 0;
    left: 0;
    height: 6px;
    background: linear-gradient(to right, #ecd2fe, #feaaaa);
  }
</style>
<hr>
<h4>References</h4>
<p>[^1]: Careful though, this is calculated relative to the <em>closest relatively positioned parent element</em> — see <a href="https://developer.mozilla.org/en-US/docs/Web/API/HTMLElement/offsetTop">HTMLElement.offsetTop on MDN web docs</a></p>


<hr>
<ul><li>Next: <a href="/console/">console.log(&#39;colours!&#39;)</a></li><li>Previous: <a href="/zeit-domains/">Setting up Zeit.co domains with GitHub Pages</a></li>
</ul>

    </main>

    <footer></footer>

    <!-- Current page: /progress-bar/ -->
  </body>
</html>
